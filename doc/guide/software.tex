\label{software}
\chapter{Software}



\section{Preparation}
\label{preparation}

Do not underestimate the effort required to flash your first LED. You
require:

\begin{itemize}
\item
  A computer with \program{git} installed and a useful shell program such as
  \program{bash}. UC has a \href{http://ucmirror.canterbury.ac.nz/}{mirror}
  for a variety of Linux distributions; we recommend Ubuntu or Mint.

\item A cloned copy of the Wacky Racers git repository, see \hyperref[project-cloning]{project cloning}.

\item
  A working ARM toolchain (arm-none-eabi-gcc/g++ version 4.9.3 or newer), see \hyperref[toolchain]{toolchain}.

\item
  An ST-link programmer and 10-wire ribbon cable for programming. You
  can get the adaptor from Scott Lloyd in the SMT lab. You will need
  to make your own cable (For a grey ribbon cable, align the red
  stripe with the small arrow denoting pin 1 on the connector. For a
  rainbow ribbon cable, connect the brown wire to pin 1.). There are
  two variants of the ST-link programmer with \textbf{different
  pinouts} so you may need to customise your programming cable.
\item
  Plenty of gumption.
\end{itemize}


\section{Git}

Your group leader should fork the Wacky Racers project template.  This
creates your own group copy of the project on the eng-git server that
you can modify, add members, etc.

Each group member then clones the group project.


\subsection{Project forking}
\label{project-forking}

The template software is hosted on the eng-git \program{Git} server at
\href{https://eng-git.canterbury.ac.nz/wacky-racers/wacky-racers-2021}{\url{https://eng-git.canterbury.ac.nz/wacky-racers/wacky-racers-2021}}.
To fork the template:

\begin{enumerate}
\item
  Go to
  \href{https://eng-git.canterbury.ac.nz/wacky-racers/wacky-racers-2021}{\url{https://eng-git.canterbury.ac.nz/wacky-racers/wacky-racers-2021}}.
\item
  Click the `Fork' button. This will create a copy of the main repository
  for the project.
\item
  Click on the `Settings' menu then click the `Expand' button for
  `Sharing and permissions'. Change `Project Visibility' to `Private'.
\item
  Click on the `Members' menu and add group members as Developers.
\end{enumerate}


\subsection{Project cloning}
\label{project-cloning}

Once your project has been forked from the template project, each group
member needs to clone it. This makes a local copy of your project on
your computer. 

If you are using an ECE computer, it is advised that you clone the
project on to a removable USB flash drive. This will make git
operations and compilation 100 times faster than using the networked
file system.

There are two ways to clone the project. If you are impatient and do not
mind having to enter a username and password for every git pull and push
operation use:
%
\begin{minted}[breaklines]{bash}
$ git clone https://eng-git.canterbury.ac.nz/groupleader-userid/wacky-racers-2021.git wacky-racers
\end{minted}

Otherwise, set up \program{ssh-keys} and use:
%
\begin{minted}[breaklines]{bash}
$ git clone git@eng-git.canterbury.ac.nz:groupleader-userid/wacky-racers-2021.git wacky-racers
\end{minted}

You can have several different cloned copies of your project in
different directories. Sometimes if you feel that the world,
and \program{git} in particular, is against you, clone a new copy,
using:
%
\begin{minted}[breaklines]{bash}
$ git clone https://eng-git.canterbury.ac.nz/groupleader-userid/wacky-racers-2021.git wacky-racers-new
\end{minted}


\section{Toolchain}
\label{toolchain}

The toolchain comprises the compiler, linker, debugger, C-libraries,
and OpenOCD.

The toolchain is installed on computers in the ESL and CAE. It should
run under both Linux and Windows.  If there is a problem ask the
technical staff.

The toolchain can be downloaded for Windows, Linux, and MacOS
from \url{https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads}.

To install parts of the toolchain separately, see the instructions in
the following subsections.


\subsection{Toolchain for Linux}

First, if using Ubuntu or Mint, ensure the latest versions are
downloaded:
%
\begin{minted}{bash}
$ sudo apt update && sudo apt upgrade
\end{minted}

Then, install the compiler:
%
\begin{minted}{bash}
$ sudo apt install gcc-arm-none-eabi
\end{minted}

Install the C and C++ libraries:
%
\begin{minted}{bash}    
$ sudo apt install libnewlib-arm-none-eabi libstdc++-arm-none-eabi-newlib
\end{minted}

Install the debugger, GDB:
%
\begin{minted}{bash}    
$ sudo apt install gdb-multiarch
\end{minted}

Install OpenOCD:
%
\begin{minted}{bash}
$ sudo apt install openocd
\end{minted}

\subsection{Toolchain for MacOS}

For MacOS machines that have \href{https://brew.sh}{homebrew}
installed, you can use the following command:

\begin{minted}{bash}
$ brew install openocd git
$ brew cask install gcc-arm-embedded
\end{minted}


\section{Your hat/racer program}
\label{your-hatracer-program}

We recommend that build your programs incrementally and that you poll
your devices with a paced loop and not use interrupts.  It is a good
idea to disable the \hyperref[watchdog-timer]{watchdog timer} until
you have robust code.

\section{Howtos}
\label{howtos}

\subsection{PIO pins}

mat91lib provides efficient PIO abstraction routines in
\wfile{mat91lib/sam4s/pio.h}.  Each pin can be configured as follows:
%
\begin{minted}{C}
    PIO_INPUT,              /* Configure as input pin.  */
    PIO_PULLUP,             /* Configure as input pin with pullup.  */
    PIO_PULLDOWN,           /* Configure as input pin with pulldown.  */
    PIO_OUTPUT_LOW,         /* Configure as output, initially low.  */
    PIO_OUTPUT_HIGH,        /* Configure as output, initially high.  */
    PIO_PERIPH_A,           /* Configure as peripheral A.  */
    PIO_PERIPH_A_PULLUP,    /* Configure as peripheral A with pullup.  */
    PIO_PERIPH_B,           /* Configure as peripheral B.  */
    PIO_PERIPH_B_PULLUP,    /* Configure as peripheral B with pullup.  */
    PIO_PERIPH_C,           /* Configure as peripheral C.  */
    PIO_PERIPH_C_PULLUP     /* Configure as peripheral C with pullup.  */
\end{minted}

Here's an example:
%
\begin{minted}{C}
  #include "pio.h"

  // Configure PA0 as an output and set default state to low.
  pio_config_set (PIO_PA0, PIO_OUTPUT_LOW);

  // Set PA0 high.
  pio_output_high (PIO_PA0);

  // Set PA0 low.  
  pio_output_low (PIO_PA0);

  // Set PA0 to value.
  pio_output_set (PIO_PA0, value);  

  // Toggle PA0.  
  pio_output_toggle (PIO_PA0);    

  // Reonfigure PA0 as an output connected to peripheral A.
  pio_config_set (PIO_PA0, PIO_PERIPH_A);

  // Reonfigure PA0 as an input with pullup enabled.
  pio_config_set (PIO_PA0, PIO_INPUT_PULLUP);

  // Read state of PIO pin.
  result = pio_input_get (PIO_PA0);
\end{minted}

Note, you can reconfigure a PIO pin on the fly.  For example, you may
want the pin to be driven by the PWM peripheral and then at some stage
forced low.  To do this, use \code{pwm\_config\_set}.


\subsection{Delaying}

mat91lib provides a macro \code{DELAY_US} in
\wfile{mat91lib/delay.h} for a busy-wait delay in microseconds
(this can be a floating point value).  The CPU just spins for a
precomputed number of clock cycles.  The argument should be a constant
so the compiler can compute the number of clock cycles.  This function
needs to be compiled with optimisation.

mat91lib also provides a function \code{delay_ms} for a busy-wait
delay in milliseconds (this must be an integer).  All this function
does is call \code{DELAY_US (1000)} the required number of times.

An example program is \wfile{test-apps/delay_test1/delay_test1.c}.


\subsection{Reading from ADC}
\label{ADC}

\wfile{test-apps/adc_usb_serial_test2/adc_usb_serial_test2.c} shows
how to read from two multiplexed ADC channels.  For more details
see \wfile{mat91lib/adc/adc.h}.

\inputminted{C}{../../src/test-apps/adc_usb_serial_test2/adc_usb_serial_test2.c}

The ADC can be also set up to stream data continuously; this is a lot
more complicated.


\subsection{Reading from pushbutton}
\label{pushbutton}

\wfile{test-apps/button_test2/button_test2.c} shows the use of a
simple button driver to read a pushbutton.  This driver does button
debouncing and state-transition detection.  For more details see
\wfile{mmculib/button/button.h}.

\inputminted{C}{../../src/test-apps/button_test2/button_test2.c}



\subsection{Disabling JTAG pins}
\label{disabling-jtag-pins}

By default \pin{PB4} and \pin{PB5} are configured as JTAG pins. You can turn
them into PIO pins or use them for TWI1 using:
%
\begin{minted}{C}
#include "mcu.h"

void main (void)
{
    mcu_jtag_disable ();
}
\end{minted}

\subsection{Watchdog timer}
\label{watchdog-timer}

The watchdog timer is useful for resetting the SAM4S if it hangs in a
loop.  It is disabled by default but can be enabled using:
%
\begin{minted}{C}
#include "mcu.h"

void main (void)
{
    mcu_watchdog_enable ();
   
    while (1)
    {
         /* Do your stuff here.  */

         mcu_watchdog_reset ();
    }
}
\end{minted}

\section{Under the bonnet}
\label{under-the-bonnet}

\file{mmculib} is a library of C drivers, mostly for performing high-level I/O.
It is written to be microcontroller neutral.

\file{mat91lib} is a library of C drivers specifically for interfacing
with the peripherals of Atmel AT91 microcontrollers such as the Atmel
SAM4S. It provides the hardware abstraction layer.

The building is controlled by \wfile{mat91lib/mat91lib.mk}. This is a
makefile fragment loaded by \wfile{mmculib/mmculib.mk}.
\file{wacky-reacers/src/mat91lib/mat91lib.mk} loads other makefile fragments for each peripheral or driver required. It also automatically generates
dependency files for the gazillions of other files that are required
to make things work.


\textbf{Please do not edit the files in the mat91lib, mmculib, and
wackylib} directories since this can lead to merge problems in the
future. If you find a bug or would like additional functionality let MPH
or one of the TAs know.
